# Arm FF-A v1.1 ACS Test scenarios
-----------------------------------------------------

This document presents the mapping of the rules in the FF-A specification to the
test cases and the steps followed in the tests. This also provides the information
about the test coverage scenarios that are implemented in the current release of
ACS and the scenarios that are planned for the future releases.


| TestName                                                         | Test Assertions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Section                           | Checked by ACS Now | Test Approach or Comments                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ffa_direct_message_error2 | FA_MSG_SEND_DIRECT_REQ:VM and SP access check | 6.4.2 | YES | 1. Send the FFA_MSG_SEND_DIRECT_REQ from S-EP to NS-EP and check for error status code. |
| ffa_spm_id_get | FFA_SPM_ID_GET | 13.9 | YES | 1. Invoke FFA_SPM_ID_GET and check for SPMC id for success status code. |
| ffa_features_intr | FFA_FEATURES: Interrupts query<br>An invocation of the FFA_FEATURES interface with Feature IDs 0x1 and 0x2 or any notification ABI, completes with an invocation of the FFA_ERROR interface with the NOT_SUPPORTED error code, if the callee does not support notifications. | 9.7 | YES | 1. Query FFA_FEATURE with Feature ID 0x1 and check for Notification pending Interrupt id for FFA_SUCCESS status code <br>2. Query FFA_FEATURE with Feature ID 0x2 and check for Scheduler Receiver Interrupt id for FFA_SUCCESS status code. <br> 3. Query FFA_FEATURE with Feature ID 0x3 and check for Managed exit Interrupt id for FFA_SUCCESS status code. |
| notification_bitmap_create | FFA_NOTIFICATION_BITMAP_CREATE | 17.1 | YES | 1. Pass invalid VM ID and check for INVALID_PARAMETERS error code. <br> 2. Try to call twice and check for DENIED error code. |
| notification_bitmap_destroy | FFA_NOTIFICATION_BITMAP_DESTROY | 17.2 | YES | 1. Pass invalid VM ID and check for INVALID_PARAMETERS error code. <br> 2. Try to call twice and check for DENIED error code. <br> 3. invoke without registering the notifications and check for DENIED status code. |
| notification_bind | FFA_NOTIFICATION_BIND | 17.3 | YES | 1. Pass invalid EP ID and check for INVALID_PARAMETERS error code. <br> 2. Pass invalid bitmap or flags and check for INVALID_PARAMETERS error code. |
| notification_unbind | FFA_NOTIFICATION_UNBIND | 17.4 | YES | 1. Pass invalid EP ID and check for INVALID_PARAMETERS error code. <br> 2. Pass invalid bitmap or flags and check for INVALID_PARAMETERS error code. <br> 3. w2/x2 Reserved(MBZ) check. |
| notification_set <br> vm_to_sp_notification <br> vm_to_sp_notification_pcpu | FFA_NOTIFICATION_SET | 17.5 | YES | 1. Pass invalid EP ID and check for INVALID_PARAMETERS error code. <br> 2. Try to set the notification if sender is not permitted to the receiver , check for DENIED status code. <br> 3. Pass invalid flags and check for INVALID_PARAMETERS error code.<br> 4. Invoke the FFA_NOTIFICATION_SET if receiver is not support receipt of notifications and check for DENIED status code. <br> 5. verify FFA_NOTIFICATION_SET for both per-Vcpu and global notifications. |
| notification_get | FFA_NOTIFICATION_GET | 17.6 | YES | 1. Pass invalid EP ID and check for INVALID_PARAMETERS error code. <br> 2. Pass invalid bitmap or flags and check for INVALID_PARAMETERS error code. |
| notification_info_get <br> vm_to_sp_notification| FFA_NOTIFICATION_INFO_GET | 17.7 | YES | 1. Invoke FFA_NOTIFICATION_INFO_GET and get the all pending notifications and target endpoint ids <br> 2. Invoke FFA_NOTIFICATION_INFO_GET for no pending notifications and check for NODATA error status code. |
| vm_to_sp_notification_pcpu <br> vm_to_sp_notification| Signaling from VM0 to SP1 | 9.5 | YES | 1. Bind the notification from SP1 to VM0. <br> 2. Register the SRI and NPI interrupt handlers <br> 3. Trigger the secure interrupt using notification_set from VM0. <br> 4. SPMC inject the SRI to scheduler and handle the SRI interrupt. <br> 5. Get the pending list id count and list ids using the notification info get and schedule target endpoint using the direct request <br> 5. Query FFA_NOTIFICATION_GET for target endpoints and pending notifications and handle the NPI interrupt. |
| vm_to_sp_notification_pcpu <br> vm_to_sp_notification| Notification binding between a VM and SP | 9.4 | YES | 1. Query if SP supports the receipt of notifications using the FFA_PARTITION_GET_INFO <br> 2. Request the SP services using the direct message from VM. <br> 3. Allocate notifications for VM and Bind the notifications to VM usng FFA_NOTIFICATION_BIND <br> 3. Respond to VM with notification details id,service etc. |
| sp_to_sp_waiting| Secure interrupt signaling and queuing for a S-EL1 SP:SP state - Waiting | 8.2 | YES | 1. Register timer interrupt and handler in SP1 endpoint. <br> 2. Program the timer count and invoke the direct response from SP1 <br> 3. excute busy loop from SP2 and wait for interrupt to signal <br> 3. After timer expires secure interrupt triggers and SPMC will preeempt the SP2 and resumes the SP1 endpoint <br> 4. Handle the inteerupt and invoke the ffa_msg_wait <br> 5. SPMC resumes the preempted endpoint(SP2).|
| vm_to_sp_waiting| Secure interrupt triggers in Non-secure state:The execution context is in the waiting state | 8.3.2 | YES | 1. Register timer interrupt and handler in SP1 endpoint. <br> 2. Program the timer count and invoke the direct response from SP1 <br> 3. excute busy loop from VM0 and wait for interrupt to signal <br> 3. After timer expires secure interrupt triggers and SPMC will preeempt the VM0 and resumes the SP1 endpoint <br> 4. Handle the inteerupt and invoke the ffa_msg_wait <br> 5. SPMC resumes the preempted endpoint(VM0).|
| sp_to_sp_blocked | Secure interrupt signaling and queuing for a S-EL1 SP:SP state - Blocked | 8.2 | YES | 1. Register timer interrupt and handler in SP1 endpoint. <br> 2. Program the timer count and invoke the direct request from SP1 to SP2 <br> 3. excute busy loop from SP2 and wait for interrupt to signal <br> 3. After timer expires secure interrupt triggers and SPMC will preeempt the SP2 and resumes the SP1 endpoint <br> 4. Check for FFA_INTERRUPT_32 and handle the interrupt and schedule the preempted SP2 using ffa_run ABI <br> 5. SPMC resumes the preempted endpoint(SP2).|
| vm_to_sp_preempt| Actions for a Non-secure interrupt: Preemption during message processing | 8.4 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Process the messgae in SP0 and generate NS physical interrupt. <br> 4. SPMC save the SP0 state and send ffa_interrupt() to VM. <br> 5.Handle the interrupt in VM and VM migrates to another PE. <br> 6. VM resumes SP execution using ffa_run(). <br> 7. SPMC restores SP state and and resumes SP execution. <br> 8. SP completes the message processing and send response back to VM using ffa_msg_send_direct_resp(). |
| vm_to_sp_managed_exit| Actions for a Non-secure interrupt: Managed exit signaled by vIRQ | 8.3.1.2 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Process the messgae in SP0 and generate NS physical interrupt. <br> 4. SPMC save the SP0 state and masks NS interrupt. To trigger managed exit SPMC triggers virtual interrupt. <br> 5. SPMC resumes SP0 execution using eret. <br> 6. Handle the virtual interrupt in SP0. <br> 7. Inform VM about managed exit in message using ffa_msg_send_direct_resp() from SP0 to VM. <br> 8. SPMC unmask the NS physical interrupt and send response to VM. <br> 9. Handle the interrupt in VM. <br> 10. VM resume the execution and send ffa_msg_send_direct_req() from VM to SP1 and check for FFA_SUCCESS status code.|
| static_mapping_dma| Static DMA isolation: An EL1 partition in either security state uses this model to enable a DMA capable device to use a memory range in the partition’s IPA space to access a memory range in the partition’s PA space | 4.2.1 | NO |1. Add static mappings to manifest. <br> 2. Try to access the memory region using SMMU upstream device <br> 3. Try to share the static memory mapping to another EP and check for error status code.|
| mem_mmio_access| This version of the Framework assumes that the following actions pertaining to the MMIO region of a device are performed through an IMPLEMENTATION DEFINED mechanism: <br> • Transfer of ownership of a device MMIO region to another partition during run-time. <br> • Grant of access to a device MMIO region to another partition during run-time. <br> • Revocation of access to a device MMIO region from a partition during run-time. | 4.9 | YES |1. Share MMIO region to EP and access the MMIO region from the borrower. <br> 2. Lend MMIO region to EP and access the MMIO region from the borrower. <br> 3. Donate MMIO region to EP and access the MMIO region from the borrower.|
| direct_msg_sp_to_vm|  In this version of the Framework, an S-Endpoint cannot send a FFA_MSG_SEND_DIRECT_REQ message through this interface to an NS-Endpoint. In this version of the Framework, an NS-Endpoint cannot send a message through FFA_MSG_SEND_DIRECT_RESP ABI interface to an S-Endpoint | 15.2 | YES |1. Send the FFA_MSG_SEND_DIRECT_REQ from S-EP to NS-EP and check for error status code. <br> 2.  Send the FFA_MSG_SEND_DIRECT_RESP from NS-EP to S-EP and check for error status code.|
| sp_el1_running| Secure interrupt signaling and queuing for a S-EL1 SP: SP state - Running | 8.2.1 | YES |1. Register timer interrupt and handler in S-EL1 endpoint. <br> 2. Program the timer count and process the message in EP. <br> 3. After timer count expires SPMC queues the Interrupt and makes sure interrupt is not triggered to the endpoint during the running state. <br> 4. SPMC pends interrupt to endpoint once it enters into blocked state and Handles the interrupt.|
| sp_waiting_el1| Actions for a Secure interrupt: Secure interrupt triggers in Non-secure state. The execution context is in the waiting state | 8.2.1 | YES |1. Register timer interrupt and handler in S-EL1 endpoint. <br> 2. Program the timer count and call FFA_MSG_WAIT. Pass execution to NS world.<br> 3. After timer count expires SPMC triggers secure virtual Interrupt to S-EL1 endpoint. <br> 4. Handle the interrupt and SPMC resumes the preempted EP.|
| vm_to_up_sp_preempt| Actions for a Non-secure interrupt: Non-secure interrupt is signaled Preemption during message processing S-EL0 and S-EL1 | 8.3.1.1 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Process the message in SP0 and generate NS physical interrupt. <br> 4. SPMC save the SP0 state and send ffa_interrupt() to VM. <br> 5. Handle the interrupt in VM and VM migrates to another PE. <br> 6. VM resumes SP execution using ffa_run(). <br> 7. SPMC restores SP state and and resumes SP execution. <br> 8. SP completes the message processing and send response back to VM using ffa_msg_send_direct_resp().|
| vm_to_sp_managed_exit <br> (FIQ Enabled in manifest) | Actions for a Non-secure interrupt: Managed exit signaled by vIRQ | 8.3.1.2 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Process the messgae in SP0 and generate NS physical interrupt. <br> 4. SPMC save the SP0 state and masks NS interrupt. To trigger managed exit SPMC triggers virtual interrupt. <br> 5. SPMC resumes SP0 execution using eret. <br> 6. Handle the virtual interrupt in SP0. <br> 7. Inform VM about managed exit in message using ffa_msg_send_direct_resp() from SP0 to VM. <br> 8. SPMC unmask the NS physical interrupt and send response to VM. <br> 9. Handle the interrupt in VM. <br> 10. VM resume the execution and send ffa_msg_send_direct_req() from VM to SP1 and check for FFA_SUCCESS status code.|
| vm_to_sp_managed_exit_1| Managed exit is supported by SP0 but not by SP1 | 8.3.1.2.1 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Send the direct messgae SP0 to SP1 <br> 4. Process the messgae in SP1 and generate NS physical interrupt. <br> 5. SPMC save the SP1 state and masks NS interrupt. To trigger managed exit SPMC triggers virtual interrupt to SP0 <br> 6. SPMC resumes SP0 execution using eret. <br> 7. Handle the virtual interrupt in SP0.  Perform bookkeeping and Send direct response to VM0. <br> 8.SPMC unmask  the NS-Int. Handle the interrupt in VM. <br> 9. VM resume the execution and send ffa_msg_send_direct_req() from VM to SP0 and check for FFA_SUCCESS status code. <br> 10. Call FFA_RUN from SP0 to  preempted SP1 and process the message from SP1 |
| vm_to_sp_managed_exit_2| Managed exit is supported by SP0 and SP1 | 8.3.1.2.1 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Send the direct messgae SP0 to SP1 <br> 4. Process the message in SP1 and generate NS physical interrupt. <br> 5. SPMC save the SP1 state and masks NS interrupt. To trigger managed exit SPMC triggers virtual interrupt to SP1 <br> 6. SPMC resumes SP1 execution using eret. <br> 7. Handle the virtual interrupt in SP1. Send direct response to SP0. <br> 8. SPMC pends managed exit signal to SP0 <br> 7. Perform bookkeeping in SP0 and send response to VM0. SPMC unmask  the NS-Int. <br> 9. Handle the interrupt in VM and VM migrates to another PE and starts executing from migrated PE. <br> 10. VM resume the execution and send ffa_msg_send_direct_req() from VM to SP1 and check for FFA_SUCCESS status code.|
| vm_to_sp_managed_exit_3| Managed exit is supported by SP1 but not SP0 | 8.3.1.2.1 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Send the direct messgae SP0 to SP1 <br> 4. Process the messgae in SP1 and generate NS physical interrupt. <br> 5. SPMC save the SP1 state and masks NS interrupt. To trigger managed exit SPMC triggers virtual interrupt to SP1 <br> 6. SPMC resumes SP1 execution using eret. SP1 sends direct response to SP0 <br> 7. Handle the virtual interrupt in SP1.  Perform bookkeeping and Send direct response to SP0. <br> 8.SPMC unmask  the NS-Int.  SP0 is preempted by SPMC.Handle the interrupt in VM. <br> 9. VM resume the SP0 execution using FFA_RUN and SP0 starts processing the message. send ffa_msg_send_direct_resp() from SP0 to VM0.|
| vm_to_sp_managed_exit_4| Managed exit is not supported by SP1 and SP0 | 8.3.1.2.1 | YES |1. Allocate RX and TX memory and register using ffa_rxtx_map() from VM and SPs. <br> 2. Fill the payload into parameter registers and send ffa_msg_send_direct_req() from VM to SP0. <br> 3. Send the direct messgae SP0 to SP1 <br> 4. Process the messgae in SP1 and generate NS physical interrupt. <br> 5. SPMC save the SP1 state and trigger NS-Int to Normal world from SP1. <br> 6. Resume SP1 execution using FFA_RUN from VM0. SP1 sends direct response to SP0. <br> 7. Process the message from SP0 and send direct response to VM0.|
| ns_intr_queued| NS-Int - Queued -SEL0 SP | 8.3.1.3 | YES |1. Register timer interrupt and handler in NS endpoint. <br> 2. Program the timer count and send a direct message to S-EL0 EP. <br> 3. After the timer count expires SPMC queues Interrupt and make sure interrupt is not triggered to an endpoint during the running state. <br> 4. Invoke direct response from S-EL0 and SPMC unmask NS-Int. Schedules the NS world and handles the interrupt.|
| ns_intr_queued| NS-Int - Queued -SEL1 SP | 8.3.1.3 | YES |1. SP0 specifies the NS-Int is queued action for while running. <br> 2. SP1 specifies the NS-Int is signaled action while running. <br> 3. SP0 runs SP1 by invoking FFA_MSG_SEND_DIRECT_REQ. <br> 4. An NS-Int triggers while SP1 is running. <br> 5. The SPMC switches to the Normal world to allow the NS-Int to be handled <br> 6. This sequence violates leaves the SP0 call chain unwound and violates the action specified by SP0. The SPMC mitigates against this scenario applying the NS-Int is queued action when the SP1 execution context is in the running state|
| ns_int_precedence| Precedence rules for NS-Int actions:The actions in response to an NS-Int are governed by the following precedence rules. < should be read as is less permissive than. <br> • NS-Int is queued < NS-Int is signaled after a ME < NS-Int is signaled. | 8.3.1.4 | YES |1. SP0 specifies the NS-Int is queued action for while running. <br> 2. SP1 specifies the NS-Int is signaled action while running1. <br> 3. SP0 runs SP1 by invoking FFA_MSG_SEND_DIRECT_REQ. <br> 4. The SPMC ensures that the action specified by SP0 takes precedence over the action specified by SP1. <br> 5. An NS-Int that triggers while SP1 is running remains pending. <br> 6. The NS-Int is handled when SPMC forwards the response from SP0 to the Normal world.|
| s_int_ec_blocked| Actions for a Secure interrupt: Secure interrupt triggers in Non-secure state: The execution context is in the blocked state | 8.3.2.1 | YES |1. Register timer interrupt and handler in S-EL1 endpoint. <br> 2. Program the timer count and send direct request to another NS EP. <br> 3. After timer count expires SPMC triggers Interrupt and make sure interrupt triggered to endpoint during the blocked state. <br> 4. Handle the interrupt and SPMC resumes preempted endpoint.|
| sp_el1_running| Actions for a Secure interrupt: Secure interrupt triggers in Secure state S-EL1 SP. The interrupt is a Self S-Int and the target execution context belongs to a S-EL1 SP. The virtual interrupt is signaled as specified in Table 8.2. The target execution context is re-enters the running state | 8.2.1 | YES |1. Register timer interrupt and handler in S-EL1 endpoint. <br> 2. Program the timer count and wait for the interrupt by sp sleep. <br> 3. After timer count expires SPMC injects the Interrupt and makes sure interrupt is triggered to the endpoint during the running state.|
| s_int_sp_preempt| Actions for a Secure interrupt: Secure interrupt triggers in Secure state S-EL1 SP: The execution context is in the preempted state. The execution context was preempted by an Other S-Int in either CPU cycle allocation mode. In this case, the queued Secure virtual interrupt is signaled when the SPMC resumes the call chain that the SP execution context is a part of subsequently.| 8.3.2.1 | YES |1. Register the first timer interrupt and handler in S-EL1 SP0 endpoint. <br> 2. Send direct message to S-EL1 SP1. SP1 registers the second interrupt. <br> 3. Second interrupt triggers first putting SP0 in preempted state. <bt> 4. First interrupt triggers and to be queued and pended by SPMC until SP0 enters running state.|
| other_secure_int|Signaling an Other S-Int in blocked state: S-EL1 execution context| 8.3.2.2.1 | YES |Table 8.4: Scenarios for signaling an Other S-Int in blocked state|
| sp_signals_vm_sp|Signaling from SP0 to SP1, VM0 and its scheduler| 9.5.1.1 | YES |1. Bind the notification from VM0 to SP0. <br> 2. Bind the notification from SP1 to SP0 <br> 3. Trigger Secure interrupt to SP0 and while the interrupt set the VM0 and SP1 notifications. <br> 4. call the FFA_MSG_WAIT from the SP0. SPMC will trigger scheduler receiver interrupt to the scheduler to inform the pending notifications. <br> 5. Query FFA_NOTIFICATION_GET for target endpoints and pending notifications. <br> 6. Primary endpoint schedules target endpoint using the direct request. <br> 7. SPMC inject pending notification interrupt to target endpoints. <br> 8. Target endpoints get the pending notification info using FFA_NOTIFICATION_GET and hadnle the notification|
| ffa_features_intr| An invocation of the FFA_FEATURES interface with Feature IDs 0x1 and 0x2 or any notification ABI, completes with an invocation of the FFA_ERROR interface with the NOT_SUPPORTED error code, if the callee does not support notifications.| 9.7 | YES |1. Query FFA_FEATURE with Feature ID 0x1 and check for Notification pending Interrupt id for FFA_SUCCESS status code <br> 2. Query FFA_FEATURE with Feature ID 0x2 and check for Scheduler Receiver Interrupt id for FFA_SUCCESS status code. <br> 3. Query FFA_FEATURE with Feature ID 0x3 and check for Managed exit Interrupt id for FFA_SUCCESS status code|
| mem_security_state_ns_bit|1. The NS bit is reserved and MBZ in an invocation of the following ABIs. <br> 1. FFA_MEM_DONATE <br> 2. FFA_MEM_LEND <br> 3. FFA_MEM_SHARE <br> 4. FFA_MEM_RETRIEVE_REQ <br> The callee at any FF-A instance must return INVALID_PARAMETERS if the bit is set by the caller.| 10.10.4.1 | YES |1. Set NS-bit[6] in the memory region attributes and invoke Share. Check for FFA_ERROR status code. <br> 2. Set NS-bit[6] in the memory region attributes and invoke Lend. Check for FFA_ERROR status code. <br> 3. Set NS-bit[6] in the memory region attributes and invoke Donate. Check for FFA_ERROR status code. <br> 4. Set NS-bit[6] in the memory region attributes and invoke Retrieve request. Check for FFA_ERROR status code.|
| ffa_mem_share|The NS bit is set to b’1 by the Hypervisor in an invocation of the FFA_MEM_RETRIEVE_RESP ABI at the Non-secure virtual FF-A instance| 10.10.4.1 | YES |1. Share the memory region from VM0 to VM1. <br> 2. Retrieve the memory region from the VM1 and check for NS-bit[6] must be equal to 1 for the Retrieve response from the NS-Hypervisor|
| mem_security_state_ns_bit|1. In response to an invocation of the FFA_MEM_RETRIEVE_REQ ABI to retrieve shared memory, <br> 1. NS bit = b’1 in the following scenarios. <br> 1. Owner of the memory region is a NS-Endpoint. <br> 2. Owner of the memory region is a SP, and the region is mapped as Non-secure in the Owner’s translation regime.| 10.10.4.1 | YES |1. Share the memory region from VM0 to SP0 <br> 2. Retrieve the memory region from the SP0 and check for NS-bit[6] must be equal to 1 for Retrieve response from the SP0|
| mem_security_state_ns_bit|2. NS bit = b’0 in the following scenario. <br> 1. Owner of the memory region is a SP, and the region is mapped as Secure in the Owner’s translation regime.| 10.10.4.1 | YES |1. Share the memory region from SP0 to SP1 <br> 2. Retrieve the memory region from the SP1 and check for NS-bit[6] must be equal to 0 for Retrieve response from the SP1|
| ffa_features_nsbit|FFA_FEATURES: FFA_MEM_RETRIEVE_REQ fid properties| 10.10.4.1 | YES |1. Query the NS-bit properties using FFA_FEATURES|
| ffa_partition_info_get|FFA_PARTITION_INFO_GET flags usage: <br> • Bit[0]: Partition count flag. <br> – b’1: Return the count of partitions deployed in the system corresponding to the specified UUID in w2 as specified in Table 13.32. <br> – b’0: Return partition information descriptors corresponding to the specified UUID in the RX buffer of the caller (see Table 13.34).| 13.8 | YES |1. Query the partition count flag = 1 and check for partition count and information in RX buffer <br> 2. Query the partition count flag = 0 and check for partition count for success code.|
| ffa_msg_send2|FFA_MSG_SEND2: S-EL0 and S-EL1| 15.1| YES | <br> 1. Copy the message to TX buffer, set sender id and receiver id and schedule the receiver endpoint. <br> 2. check message from receiver and validate. <br> 3. Set bit[0] and Bit[31:2] in flags and check for Invalid parameters . <br> 4. Try to send message where RX buffer is not free and check for Busy status code. <br> 5. Try to send message. <br> 6. Receiver endpoint does not support receipt of partition messages through indirect messaging. Check for Denied status code.|
| ffa_msg_send2|FFA_MSG_SEND2: RX buffer full notification| 15.1 | YES |1. Bind the RX_buffer_Notification to sender from the receiver. <br> 2. copy the message into TX buffer and invoke FFA_MSG_SEND2 ABI. <br> 3. Partition manager copy sender TX buffer to Receiver RX buffer and pends RX_buffer_Notification <br> 4. Scheduler schedules receiver to process the pending notification. <br> 5. Follow above steps by setting Delay schedule receiver interrupt|

